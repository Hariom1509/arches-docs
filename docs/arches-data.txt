############
Arches Data
############

Physical Data model
===================

.. note:: This section is most useful for those who wish to issue sql queries directly against the Arches backend PostgreSQL database.


The Arches physical data model consists of tables and referential integrity constraints implmented within a PostgreSQL database.  It is driven by a requirement that Arches be able to support data management for most any cultural heritage application in the world without the need to modify the underlying table structure.  


To accomplish this, Arches stores both metadata - defining the set of resource types and attributes available to store - and business data - inventorying and describing the cultural heritage resources themselves.


The physical data model is best understood when broken into three distinct parts: Ontology Data,  Reference Data, and Resources Data.  The ``entity_types`` table plays a role in all three of these parts of the data model. 


[Arches ERD.jpg]


**Ontology Data**


The ontology portion of the data model stores the metadata sourced from the resource graphs.  These tables therefore contain information about what is the valid set of semantic "types" of data (by default, Arches uses CIDOC CRM [http://www.cidoc-crm.org/] to define these things), and what are the valid types of relationships between them.


**Reference Data**


This is where Arches stores the hierarchical controlled vocabularies that power drop down lists in Arches applications.  Items in drop-down lists are called "concepts".  Metadata about concepts, such as their labels and scope notes are stored in the related ``values`` table, and relationships between concepts are managed in the ``relations`` table.


**Resources Data**


The Resources Data section is where Arches stores the actual cultural heritage resource information - the business data. The key concepts to understand in this portion of the database are entities, relations, and "business tables".  

Entities within an Arches database represent one of three things:

#. the existence of a cultural heritage resource
#. an attribute of a cultural heritage resource, or
#. a record required to maintain ontological consistency between attributes

Relations represent relationships between entities within an Arches database.  Records in this table indicate a relationship between two distinct entities.

Business tables contain strings, numbers, dates, or geometries that capture actual attributes of resources.  These work by linking entities (by ``entityid``) to respective values.

One special business table is the domains table.  It is unique in that it only stores ``valueid`` (as a foreign key from the values table within the Reference Data) in order to relate entities that are constrained by a controlled vocabulary to its appropriate Reference Data records.

**Entity Types**

The ``entity_types`` table really belongs in all three categories because:

* they classify entities into an "attribute" that an implementor defines in the course of creating resource graphs. 
* they link the attribute to one of a series of ontological categories that, by default, is based on CRM
* they specify which attributes must be powered by drop-down lists from the Reference data section.

In the simplest potential case, a resource that happens to be a person with a name will, at a minimum, contain two entities and one relation.  That is, an entity that represents the existence of the resource, another entity that contains the person's name, and a relation that links the two together.

.. Hint:: Each of these three sections within Arches database are contained in seperate namespaces that Postgres calls "schemas."  Each schema, in turn, has wthin in it two predefined views called vw_nodes and vw_edges.  The Arches application does not use these views, but they could be useful in developing graph-based outputs of resource instances, resource graphs, and RDM graphs.


Resource Graphs
===============

A "Resource Graph" is the logical framework that is used by Arches to define the set of resources and attributes of resources to be managed.  

Arches applications must provide a resource graph for each resource type being inventoried.

One example of a fully featured resource graph from the Arches HIP application is ``HERITAGE_RESOURCE.E18``.


[image]


While this visualization is useful for creating, editing, and analyzing the resource and its available attributes, the graph's data is populated into Arches from two specially formatted csv files named ``{resource type name}_nodes.csv`` and ``{resourcetype name}_edges.csv``.  

.. note:: As of the writing of this document, the Arches developers' primary tool to develop and visualize the resource graphs is Gephi (http://www.gephi.org/).  However, it is possible that a future version of Arches may include tools that support resource graph development and visualization.

Regardless of how the nodes and edges csv files are created, they must include the columns defined below.

**Nodes:**

* ``Id``: a unique and arbitrary ID for each record within the file
* ``Label``: the name of the entity type that is stored in a given node.  This name must be concatenated with a dot (".") and the CRM class associated to that entity type
* ``mergenode``: defines the upstream node that occurs one time (and only one time) within a given resource instance.  In most cases, that node is the one that represents the resource itself.
* ``businesstable``: identifies the respective business table (strings, numbers, dates, geometries, domains) that will store values associated to instances of the node. This value should be left null for nodes that never store a business data. 

**Edges:**

* ``Source``: the ID of the source node
* ``Target``: the ID of the target node
* ``Label``: the semantic CRM "property" that allows them to connect to each other.

.. note:: Arches comes loaded with the semantic properties defined in the CIDOC CRM (http://www.cidoc-crm.org/).  Look to the CRM documentation to learn about the list of available properties.


Ontologies
----------

The fundamental role of resource graphs is to define a suite of resource types, their attributes, and relationships between them.  However, the graph also supports associating nodes and edges within the it to semantic classes and properties defined in CIDOC CRM.  

.. note:: One should refer to CIDOC CRM (http://www.cidoc-crm.org/) to make an informed decision about what class or property to assign to nodes and edges respectively.

For those who do not care about CRM, ontologies or semantic interoperability, the simplest way to make a valid graph is to assign all nodes as "E1" and all edges as "P1".  

Reference Data Graph
====================

The reference data graph stores information necesary to use robustly managed thesauri as picklists (sometimes called "controlled vocabularies") within resource data entry forms.  The functional requirements for reference data in the cultural heritage field are quite robust, and best defined in SKOS documentation (http://www.w3.org/2004/02/skos/).  For the purpose of this document, we will outline a few of the most important and visible requirements:

* Ability to associate sets of reference data entries as valid selections in dropdown lists for "domain" nodes in the resource graph
* Ability to associate arbitrary attributes (such as preferred labels, alternate labels, scope notes, sort order) to entries within the reference data
* Ability to store words associated to given reference data entries in multiple languages (to support internationalization)
* Ability to relate entries to each other in semanticly rich heirarchies

Like the resource data graph, reference data is also stored in a graph structure.  But instead of entities and relations, the reference data includes ``concepts`` and ``relations``.  The types of avaialble relations are best categorized as ``semantic relations`` and ``collections``.  The meaning behind concepts is not only derived from its own individual description (or scope note), but also from its context from its position within a heirarchy of concepts.  Semantic relations are the connective tissue of heirarchical relationships that infuse meaning into concepts.  Collections, on the other hand, are used primarily for the purpose defining which concpets belong in a given Entity Types' dropdown list regardless of its position within a semantic heirarchy.  In short, semantic relationships infuse meaning and collections define the content of dropdown lists.  This infers that the Arches RDM is in itself a sophisticated thesaurus management system.


Loading Authority Files
-----------------------
Arches supports two formats for loading controlled vocabularies to its Reference Data graph.  The first approach, using csv files, is designed to support loading of legacy data to Arches.  As such, data are prepared and formatted and then uploaded as part of the installation of a specific Arches Application.  The second approach uses SKOS files. With SKOS files the assumption is that a given Arches application is already up and running, and that a person will use commands in the RDM's user interface to pull in new thesauri from SKOS-formatted files.

If you chose to create your own authority files those can be loaded using the following command from inside ||this directory||::
	
	python manage.py packages -o load_concept_scheme --source '{PATH TO AUTHORITY FILES}'


from .csv
------------
The following steps outline how to create your own csv-formatted authority documents for use in a system implmenation. These steps can be followed using excel as your text editor but the final file must be saved as a utf-8 formatted csv file.

Data is required for all columns in the authority file with the exception of 'AltLables'.

	1.) Create a text file and paste the following text to the first line::

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider

	2.) On the second line we will begin creating our concept. Start by creating a conceptid that will be unique both within this file and across all authority document files. A good pattern to follow is to use the name of the authority document itself (with '_' instead of spaces and minus the AUTHORITY_DOCUMENT.csv) with the number of the particular concept within the authority document appended. As an example, if your authority document is name 'EXAMPLE_AUTHORITY_DOCUMENT.csv' the first concept within the authority document would have the conceptid 'EXAMPLE_1'::

		//EXAMPLE_AUTHORITY_DOCUMENT.csv

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider
		EXAMPLE_1,
		EXAMPLE_2,

	3.) Next, add your preferred label for the concept. In most cases this will be the value you have in mind or from your data that you would like to use for the domain list this authority document will be related to::

		//EXAMPLE_AUTHORITY_DOCUMENT.csv

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider
		EXAMPLE_1,Example concept label,
		EXAMPLE_2,Second example concept,

	4.) Now add an alternate label for your concept. This may be left blank if you have no alternate label for your concept::

		//EXAMPLE_AUTHORITY_DOCUMENT.csv

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider
		EXAMPLE_1,Example concept label,Alternate concept label,
		EXAMPLE_2,Second example concept,Second alternate concept label,

	5.) Then add a Parent ConceptID. If the concept is not heirarchically related to any other concept in the authority document then the Parent ConceptID will be the full name of the authority document itself. If the concept is heirarchically related to another concept in the authority file, ensure the parent concept is defined above the child concept and input the parent concepts' conceptid here. In our example I have added a second concept that references the first concept as its parent::

		//EXAMPLE_AUTHORITY_DOCUMENT.csv

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider
		EXAMPLE_1,Example concept label,Alternate concept label,EXAMPLE_AUTHORITY_DOCUMENT.csv,
		EXAMPLE_2,Second example concept,Second alternate concept label,EXAMPLE_1,

	6.) Next, add a Concept Type. The only two valid values for ConceptType are: Index, and Collector. For more information on what the difference between these two concept types refer to the the general Arches documentation (http://arches3.readthedocs.org/en/latest/arches-data/#loading-reference-data)::

		//EXAMPLE_AUTHORITY_DOCUMENT.csv

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider
		EXAMPLE_1,Example concept label,Alternate concept label,EXAMPLE_AUTHORITY_DOCUMENT.csv,Collector,
		EXAMPLE_2,Second example concept,Second alternate concept label,EXAMPLE_1,Index,

	7.) Optionally, you can add a Provider for your concept. This value provides context for where the concept came from::

		//EXAMPLE_AUTHORITY_DOCUMENT.csv

		conceptid,PrefLabel,AltLabels,ParentConceptid,ConceptType,Provider
		EXAMPLE_1,Example concept label,Alternate concept label,EXAMPLE_AUTHORITY_DOCUMENT.csv,Collector,Organization_1
		EXAMPLE_2,Second example concept,Second alternate concept label,EXAMPLE_1,Index,Organization_2

	8.) Save your document.

	9.) IMPORTANT: Finally, we have to make sure our authority file maps to a 'domain node' in a resource graph. To do this either create or open the existing 'ENTITY_TYPE_X_ADOC.csv' file that should reside in the same directory as your authority files (this file must be named ENTITY_TYPE_X_ADOC.csv).

		If you are modifying an existing ENTITY_TYPE_X_ADOC.csv file skip to step b below.

		a.) Copy and past the following text into the file on the first line::

			entitytype,authoritydoc,authoritydocconceptschemename

		b.) Add a comma separated entry with the following information: the entity type to which you would like your authority documented associated (exactly how it is spelled in the resource graph including the .E## suffix), the name of the exact name of the authority document, and the concept scheme into which you would like to load this authority document::

			//ENTITY_TYPE_X_ADOC.csv

			entitytype,authoritydoc,authoritydocconceptschemename
			EXAMPLE_NODE.E55,EXAMPLE_AUTHORITY_DOCUMENT.csv,Example Concept Scheme Name

Properly structured Authority files can be loaded into Arches using the following command from inside ||this directory||::
	python manage.py packages -o load_concept_scheme --source '{PATH TO AUTHORITY FILES}'			
			

from .skos
---------
Do we even have a way to point to folder full of skos files and say load them?

Loading Business Data
======================
Resources and their attributes can be loaded to Arches resource graphs using one of two formats: shapefiles or a specially formatted text file with a ".arches" extension.  

Shapefiles have the significant limitation that they cannot define explicit relationships between resources and they can only hold one attribute value per entity type. 

Dot Arches files, on the other hand, take a key-value pair approach populating resource graphs with resources with attributes.  Therefore, they are able to add as many of a given attribute as exists in the data.  The downside of the dot arches format is that it can take a significant data processing or reformatting effort to get a significant amount of source data ready for loading to Arches from this format.



from .arches
------------
The .arches format is intended to support upload of Arches data containing rich content and complex relationships while also being acheivable to format properly using common software like MS Excel or OpenOffice.

The dot arches file is a pipe ("|") delimited text file containing the following column headers:

RESOURCEID
RESOURCETYPE
ATTRIBUTENAME
ATTRIBUTEVALUE
GROUPID

The file is really just a list of business entities to be loaded to Arches.  By "business entities", we mean it only requires those entities that actually store a business value.  In this way, the .arches format is obfuscated from the details of the resource graph that it is being loaded to.  The only real requirement is that the entity types referenced in the ATTRIBUTENAME field exist within the resource graph that the data is being loaded into.

The format fundamentally takes a key-value pair approach to storage where the ATTRIBUTENAME defines the key (actually the entity type as defined in the resource graph) and the ATTRIBUTEVALUE defines the business value of the entity.

RESOURCEID is a user-generated unique ID for each individual resource.  Since any given resource will likely have many attributes, it is expected that a given RESOURCEID value will repeat on many lines.  As a point of reference, Arches will create a seperate unique ID for any resource that is laoded and will save the RESOURCEID provided within the .arches file as an external reference of type "Legacy ID".

RESOURCETYPE specifies which resource type graph a given attribute is being loaded to.  In the Arches HIP Application, the available resource types include: ACTIVITY.E7, ACTOR.E39, HERITAGE_RESOURCE.E18, HERITAGE_RESOURCE_GROUP.E27, HISTORICAL_EVENT.E5, and INFORMATION_RESOURCE.E73.

ATTRIBUTENAME specifies the node from the appropriate resource graph that the supplied value (in the ATTRIBUTEVALUE column) will load to.  Note that ATTRIBUTENAME is synonymous with entitytypeid.  Essentially, you are specifying the enitytypeid of the (business) entity that you are loading to the system.

ATTRIBUTEVALUE stores the the actual business value of the enitit.  ATTRIBUTEVALUE values must conform to the datatype specified by the businesstable associated to the ATTRIBUTENAME. See the Postgres documentation for appropriate formatting for strings, numbers, and dates.  See the notes below for formatting details on Geometries and Domains.

.. note:: Geometry: Any value that is to be loaded as a geometry must be formatted using Well Known Text (or "WKT" for short) with coordinates set to ESPG 4326 or latitude/longitude WGS84 (http://spatialreference.org/ref/epsg/4326/).  WKT is a standard format for storing vector geometry as human-readable text.  Details of the standard can be found here: https://portal.opengeospatial.org/files/?artifact_id=54797, and wikipedia has a much more readable aggregation of the relevant information here: http://en.wikipedia.org/wiki/Well-known_text.

.. note:: Domains: Another special case here is values assocaited to ATTRIBUTENAME(s) that link to the "domains" businesstable.  In those cases, the value store in ATTRIBUTEVALUE must be the conceptid fed in from csv-formatted "authority files."   More on authority files is available in the "Loading Reference Data" section.

GROUPID is inteded to support cases where business values stored in seperate nodes within the resource graph must be assocaited to each other. To illustrate the need, the classic example is an ACTOR resource graph that contains both FIRST_NAME.E1 and LAST_NAME.E1 as seperate nodes.  In that case, a an ACTOR that has two seperate names would need to know which first name and which last name go together.  (An example might be Mark Twain and Samuel Clemens.)  To group these appropriately, the two rows containing "Mark" and "Twain" should share a common GROUPID value and the two rows containing "Samuel" and Clemens" should have the same.  



-syntax
-arches-level validation
 validate_row_syntax - validates format of archesfile row
validate_entitytype - checks that entitytype listed exists in the resource graph for that resource type
valdiate_attribute_value - checks that the attributevalue is valid within the context of the businesstablename (e.g. a date is actually formatted correclty, a number is really a number and not a string)
validate_contiguousness - checks that resource attributes are on contiguous lines in the .arches file
validate_relations_file - checks that all resourceids listed in the .relations file exist in the .arches file


from .shp
---------


An Example Data Load
--------------------

Below is a very simple resource graph, set of authority documents, and .arches file. The intent is to quickly illustrate how a logical model is defined and how data can be migrated into it.

[image of resource graph]

As with all resource graphs, the RDM must be populated with the data necesary to populate data into those nodes whose store data in the businesstable "domains".  Below are images of a set of csv format "authority files" that would necesarily go with this hypothetical resource graph.

[image of auth docs for heritage]
[ resource type and name type]

Finally, the .arches file below shows how to structure data for two distinct resources and their attributes:



- use a very simple example of a resource graph.  Graph should contain a mergenode, grouping node, and an E55 entitytype, and a geometry.  Show an example auth doc and .arches file for loading data to the graph.


Exporting Data
==============

